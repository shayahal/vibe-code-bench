# Pattern Library - Reusable Solutions

## Agent Patterns

### Pattern: LangChain Agent Registration
**Context**: Registering agents with the orchestrator
**Code**:
```python
orchestrator.register_agent(
    name="agent_name",
    tools=[tool1, tool2],
    system_prompt="Agent description and capabilities",
    description="What the agent does"
)
```
**When to Use**: When creating new agents
**Notes**: Tools must be LangChain BaseTool instances

---

### Pattern: Tool Creation with StructuredTool
**Context**: Creating tools for LangChain agents
**Code**:
```python
from langchain_core.tools import StructuredTool

def my_tool_func(param: str) -> str:
    """Tool description."""
    return result

tool = StructuredTool.from_function(
    func=my_tool_func,
    name="tool_name",
    description="Tool description for agent"
)
```
**When to Use**: When creating reusable agent tools
**Notes**: Use StructuredTool for type safety

---

### Pattern: Async Task Execution
**Context**: Executing tasks with orchestrator
**Code**:
```python
async def run_task():
    task_id = orchestrator.create_task(
        description="Task description",
        agent_name="agent_name"
    )
    result = await orchestrator.execute_task(task_id)
    return result
```
**When to Use**: When executing agent tasks
**Notes**: Always use async/await for task execution

---

### Pattern: Logging Setup
**Context**: Setting up logging for modules
**Code**:
```python
import logging

logger = logging.getLogger(__name__)
if not logger.handlers:
    handler = logging.StreamHandler()
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    handler.setFormatter(formatter)
    logger.addHandler(handler)
    logger.setLevel(logging.INFO)
```
**When to Use**: In any module that needs logging
**Notes**: Prevents duplicate handlers

---

### Pattern: Mock-Based Testing
**Context**: Testing without external dependencies
**Code**:
```python
@pytest.fixture
def mock_session():
    session = MagicMock()
    response = Mock()
    response.status_code = 200
    response.text = "<html>Test</html>"
    session.get.return_value = response
    return session
```
**When to Use**: When testing HTTP-dependent code
**Notes**: Mock external dependencies

---

## Anti-Patterns

### Anti-Pattern: Direct API Calls in Tests
**Problem**: Tests depend on external services
**Solution**: Use mocks and fixtures
**Why**: Tests should be fast and reliable

---

### Anti-Pattern: Hardcoded API Keys
**Problem**: Security risk, inflexibility
**Solution**: Use environment variables
**Why**: Security and flexibility

---

### Anti-Pattern: Skipping Error Handling
**Problem**: Unhandled exceptions crash agents
**Solution**: Try/except with logging
**Why**: Robustness and debugging

---

## Best Practices

### Agent Development
1. Always provide clear system prompts
2. Document all tools thoroughly
3. Handle errors gracefully
4. Log important operations
5. Write tests for all tools

### Testing
1. Mock external dependencies
2. Test edge cases
3. Use fixtures for common setup
4. Keep tests fast
5. Document test purpose

### Logging
1. Use appropriate log levels
2. Include context in messages
3. Log errors with exceptions
4. Don't log sensitive data
5. Structure logs consistently

---

## Code Snippets

### Creating a Test Agent
```python
def create_test_agent(orchestrator, name, tools, prompt):
    orchestrator.register_agent(
        name=name,
        tools=tools,
        system_prompt=prompt,
        description=f"Test agent: {name}"
    )
```

### Error Handling Pattern
```python
try:
    result = operation()
    logger.info(f"Operation completed: {result}")
    return result
except Exception as e:
    logger.error(f"Operation failed: {str(e)}")
    logger.exception(e)
    raise
```

---

## Pattern Updates

**2025-01-15**: Added logging patterns
**2025-01-15**: Added testing patterns
**2025-01-15**: Added agent patterns

---

## How to Contribute

1. Document patterns as you discover them
2. Include code examples
3. Explain when to use
4. Note any gotchas
5. Update when patterns evolve
